# declarative syntax
module Module < Server
  eigenmodule
    def new
      spawn { self.lookup(:loop) } # self::loop
    end
    
    def new(state)
      spawn { self.lookup(:loop)(state) } # self::loop(state)
    end
  end

  def register(state, name, function)
    state['functions'][name] := function
    function:name = name
    function:module = self
  end
end

# imperative implementation of the above module
Module = Module.new
Module.eigenmodule.eval do
  self:register('new', Function.new(
    :arguments => [],
    :instructions => InstructionSequence.new do
      push_lit 'Module'
      lookup
      push_lit :function
      push_lit :loop
      call
      spawn
    end
  ))
  self:register('new', Function.new(
    :arguments => [Variable.new(:state)],
    :instructions => InstructionSequence.new do
      
    end
  ))
end

module InstructionSequence < Server
  eigenmodule
    def new(fn)
      spawn do
        state = {:instructions => [], :literal_frame => LiteralFrame.new}
        self::write(state, fn)
        self::loop(state)
      end
    end
  end
  
  def write(state = {:instructions => instructions, :literal_frame => literal_frame}, closure)
    def push_lit(name)
      instructions.push(Instructions::Push.new(literal_frame.register(name)))
    end
    def lookup
      instructions.push(Instructions::Lookup.new)
    end
    def send
      instructions.push(Instructions::Send.new)
    end
    eval(closure)
  end    
end


module Function
  def loop
    
  end
  
  def initial_state(instructions)
    {:instructions => instructions}
  end
end

#================
function calls in a procedure evaluated by a process
call: lookup symbols in the environment of the functions construction (static scope)
eval: if a symbol is not found in the function's static scope, look in its dynamic scope, that is the scope of eval's caller.

static scope: lexically-scoped variables and entries in the lexically-containing module

#.
